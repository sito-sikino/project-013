# 2025-08-13_15-45 体感速度最適化実装

## 完了タスク
- [x] 9-2 体感速度  
**AC**: 受信→Typing 呼び出しがイベントハンドラ内で即時。

## 実装の背景
Discord Multi-Agent Systemにおける体感速度の最適化。
従来の実装では、ユーザーメッセージ受信からTyping表示まで最大30秒以上の遅延が発生していた（Redis読み込み→LLM生成→Typing表示の順序）。
この問題を解決し、ユーザーが「即座に応答している」と感じられる体感速度を実現。

## 設計意図
- **即時フィードバック**: バリデーション直後に即座にTyping表示
- **知覚的応答性**: ユーザーが「すぐに反応した」と感じる100ms以内応答
- **二段階Typing**: 1) 即時Typing（チャンネル基準選択） 2) 最終Typing（LLM選択）
- **既存機能保持**: 9-1の完全なフロー（store.append→common_sequence）を維持
- **パフォーマンス重視**: 軽量なボット選択ロジック（複雑な処理は後回し）

## 問題分析（Before/After）

### Before（9-1実装）
```
ユーザーメッセージ → バリデーション → Redis格納 → common_sequence
                                          ↓ (2-30秒後)
                                       Redis読み込み → LLM生成 → Typing → Send
```
**問題**: Typing表示まで2-30秒の遅延

### After（9-2実装）
```
ユーザーメッセージ → バリデーション → **即時Typing** → Redis格納 → common_sequence
                                    ↓ (~100ms)      ↓ (2-30秒後)
                               ユーザーが即座に認知     LLM生成 → 最終Typing → Send
```
**解決**: 100ms以内の即時Typing表示

## 実装詳細

### TDDサイクル実施
1. **Red**: test_response_speed.py作成（19テスト）
   - 即時Typing・実行順序・応答速度・ボット選択・パフォーマンス・既存機能保持

2. **Green**: app.pyに2つの機能実装
   - `select_typing_bot()`: チャンネル基準の高速ボット選択
   - `on_user()`: バリデーション直後の即時Typing呼び出し

3. **Refactor**: 品質確認
   - 既存パターンとの一貫性確認（関数内インポート維持）
   - パフォーマンス最適化確認

## 新機能詳細

### select_typing_bot関数
```python
def select_typing_bot(channel_name: str, text: str) -> str:
    """即時Typing用の簡単なボット選択"""
    channel_bot_preference = {
        "command-center": "spectra",  # 汎用・管理系
        "creation": "paz",           # 創作系  
        "development": "lynq",       # 開発系
        "lounge": "spectra",         # 雑談系
        "unknown": "spectra"         # デフォルト
    }
    return channel_bot_preference.get(channel_name, "spectra")
```

**特徴**:
- **高速選択**: 辞書ルックアップ（O(1)）で即座に決定
- **チャンネル特化**: 各チャンネルの特性に応じたボット選択
- **フォールバック**: 未知チャンネルはSpectraがデフォルト対応

### 即時Typing呼び出し（on_user拡張）
```python
# バリデーション直後
channel_name = get_channel_name_from_id(channel)

# 即時Typing表示（体感速度向上）
typing_bot = select_typing_bot(channel_name, text)
await discord.typing(typing_bot, channel)

# 既存フロー継続
store.append("user", channel_name, text)
await common_sequence(...)
```

**実行順序**:
1. **バリデーション** (既存)
2. **🆕 即時Typing** (新機能) 
3. **Redis格納** (既存)
4. **common_sequence** (既存)

## 二段階Typing戦略

### 第1段階: 即時Typing（新機能）
- **目的**: 即座のユーザーフィードバック
- **ボット選択**: チャンネル基準（高速）
- **タイミング**: バリデーション直後（~100ms）
- **表示内容**: "○○ is typing..."

### 第2段階: 最終Typing（既存）
- **目的**: 実際の応答者表示
- **ボット選択**: LLM判断（文脈考慮）
- **タイミング**: LLM生成直後（2-30秒後）
- **表示内容**: "実際の応答者 is typing..."

**利点**: 
- ユーザーは即座に反応を感じる
- 最終的には最適なボットが応答
- 重複Typingも自然（Discord標準動作）

## パフォーマンス改善結果

### 応答時間目標
- **目標**: 100ms以内でTyping表示
- **実装**: バリデーション→辞書ルックアップ→discord.typing()
- **測定**: test_typing_response_time_under_100ms()で検証

### 最適化ポイント
1. **軽量ボット選択**: 複雑なAI判断を回避
2. **関数内インポート**: 既存パターン維持（循環インポート回避）
3. **エラー分離**: Typing失敗が後続処理をブロックしない設計

## ボット選択戦略

### チャンネル別デフォルト
- **command-center**: Spectra（汎用・管理系）
- **creation**: Paz（創作・アイデア系）
- **development**: LynQ（技術・開発系）
- **lounge**: Spectra（雑談・フリートーク）

### 選択根拠
- **高速性重視**: 複雑な文脈分析は後段（LLM）で実行
- **チャンネル特性**: 各チャンネルの主要用途に応じた最適化
- **フォールバック**: 不明な場合はSpectra（最も汎用的）

## 副作用 / 注意点
- **二重Typing**: 即時+最終の2回Typing表示（自然な挙動）
- **ボット変更**: 即時Typingと最終応答者が異なる場合がある
- **エラー時Typing**: 後続処理失敗でもTypingは既に表示済み
- **パフォーマンス依存**: discord.typing() API呼び出しのレイテンシに依存

## 関連ファイル・関数
- `/home/u/dev/project-013/app/app.py`
  - `select_typing_bot()`: 高速ボット選択実装
  - `on_user()`: 即時Typing呼び出し追加
  - `common_sequence()`: 既存フロー（最終Typing）
- `/home/u/dev/project-013/test_response_speed.py`
  - 全19テストケース（即時・順序・速度・選択・パフォーマンス・保持確認）

## テストカバレッジ
- **即時Typing**: バリデーション直後のTyping呼び出し確認
- **実行順序**: typing → store_append → common_sequence順序
- **応答速度**: 100ms以内のTyping表示時間測定
- **ボット選択**: チャンネル別適切選択・未知チャンネル対応
- **パフォーマンス**: 同時実行・遅い操作影響なし・エラー分離
- **既存機能**: バリデーション・完全フロー・機能保持確認

## 体感速度向上効果
- **Before**: 2-30秒後にTyping表示（LLM処理後）
- **After**: ~100ms以内にTyping表示（バリデーション直後）
- **改善度**: 20-300倍の応答速度向上
- **ユーザー体験**: 「即座に反応する賢いボット」の印象

## コミット情報
```
feat: 9-2 体感速度最適化（即時Typing→100ms以内応答）
```